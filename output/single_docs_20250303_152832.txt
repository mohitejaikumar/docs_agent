[{'id': 1, 'docs_id': 1, 'type': 'module', 'name': 'fdtdx.fdtd.update', 'description': 'Module for updating detector states and handling interfaces in FDTD simulations.', 'url': 'https://ymahlau.github.io/fdtdx/api/fdtd/interfaces/', 'error': False}, {'id': 2, 'module_id': 1, 'docs_id': 2, 'type': 'function', 'name': 'update_detector_states', 'description': 'Updates the states of detectors in the FDTD simulation.', 'signature': 'update_detector_states()', 'parameters': [], 'examples': [], 'url': 'https://ymahlau.github.io/fdtdx/api/fdtd/interfaces/#fdtdx.fdtd.update.update_detector_states', 'error': False}, {'id': 3, 'module_id': 1, 'docs_id': 3, 'type': 'function', 'name': 'collect_interfaces', 'description': 'Collects interfaces from the FDTD simulation.', 'signature': 'collect_interfaces()', 'parameters': [], 'examples': [], 'url': 'https://ymahlau.github.io/fdtdx/api/fdtd/interfaces/#fdtdx.fdtd.update.collect_interfaces', 'error': False}, {'id': 4, 'module_id': 1, 'docs_id': 4, 'type': 'function', 'name': 'add_interfaces', 'description': 'Adds interfaces to the FDTD simulation.', 'signature': 'add_interfaces()', 'parameters': [], 'examples': [], 'url': 'https://ymahlau.github.io/fdtdx/api/fdtd/interfaces/#fdtdx.fdtd.update.add_interfaces', 'error': False}, {'id': 1, 'docs_id': 1, 'type': 'module', 'name': 'fdtdx.fdtd.update', 'description': 'Module containing functions for updating detector states and handling interfaces in FDTD simulations.', 'url': None, 'error': False}, {'id': 2, 'module_id': 1, 'docs_id': 2, 'type': 'function', 'name': 'update_detector_states', 'description': 'Updates detector states based on current field values. Handles field interpolation for accurate detector measurements.', 'signature': 'update_detector_states(time_step: jax.Array, arrays: ArrayContainer, objects: ObjectContainer, H_prev: jax.Array, inverse: bool) -> ArrayContainer', 'parameters': [{'name': 'time_step', 'type': 'jax.Array', 'docs_id': 3, 'description': 'Current simulation time step', 'default_value': '_required_', 'is_optional': False}, {'name': 'arrays', 'type': 'ArrayContainer', 'docs_id': 4, 'description': 'Container with E, H fields and material properties', 'default_value': '_required_', 'is_optional': False}, {'name': 'objects', 'type': 'ObjectContainer', 'docs_id': 5, 'description': 'Container with detectors and other simulation objects', 'default_value': '_required_', 'is_optional': False}, {'name': 'H_prev', 'type': 'jax.Array', 'docs_id': 6, 'description': 'Previous H field values for interpolation', 'default_value': '_required_', 'is_optional': False}, {'name': 'inverse', 'type': 'bool', 'docs_id': 7, 'description': 'Whether this is a forward or reverse update', 'default_value': '_required_', 'is_optional': False}], 'examples': [{'type': 'Updating detector states', 'code': 'updated_arrays = fdtdx.fdtd.update.update_detector_states(time_step, arrays, objects, H_prev, inverse)', 'description': 'This example shows how to use the update_detector_states function to update the detector states in an FDTD simulation.'}], 'url': None, 'error': False}, {'id': 3, 'module_id': 1, 'docs_id': 8, 'type': 'function', 'name': 'collect_interfaces', 'description': 'Collects field values at PML interfaces for gradient computation. Part of the memory-efficient automatic differentiation implementation.', 'signature': 'collect_interfaces(time_step: jax.Array, arrays: ArrayContainer, objects: ObjectContainer, config: SimulationConfig, key: jax.Array) -> ArrayContainer', 'parameters': [{'name': 'time_step', 'type': 'jax.Array', 'docs_id': 9, 'description': 'Current simulation time step', 'default_value': '_required_', 'is_optional': False}, {'name': 'arrays', 'type': 'ArrayContainer', 'docs_id': 10, 'description': 'Container with fields and material properties', 'default_value': '_required_', 'is_optional': False}, {'name': 'objects', 'type': 'ObjectContainer', 'docs_id': 11, 'description': 'Container with PML and other simulation objects', 'default_value': '_required_', 'is_optional': False}, {'name': 'config', 'type': 'SimulationConfig', 'docs_id': 12, 'description': 'Simulation configuration with gradient settings', 'default_value': '_required_', 'is_optional': False}, {'name': 'key', 'type': 'jax.Array', 'docs_id': 13, 'description': 'Random key for compression', 'default_value': '_required_', 'is_optional': False}], 'examples': [{'type': 'Collecting interface values', 'code': 'updated_arrays = fdtdx.fdtd.update.collect_interfaces(time_step, arrays, objects, config, key)', 'description': 'This example shows how to use the collect_interfaces function to collect field values at PML interfaces.'}], 'url': None, 'error': False}, {'id': 4, 'module_id': 1, 'docs_id': 14, 'type': 'function', 'name': 'add_interfaces', 'description': 'Adds previously collected interface values back to the fields. Part of the memory-efficient automatic differentiation implementation.', 'signature': 'add_interfaces(time_step: jax.Array, arrays: ArrayContainer, objects: ObjectContainer, config: SimulationConfig, key: jax.Array) -> ArrayContainer', 'parameters': [{'name': 'time_step', 'type': 'jax.Array', 'docs_id': 15, 'description': 'Current simulation time step', 'default_value': '_required_', 'is_optional': False}, {'name': 'arrays', 'type': 'ArrayContainer', 'docs_id': 16, 'description': 'Container with fields and material properties', 'default_value': '_required_', 'is_optional': False}, {'name': 'objects', 'type': 'ObjectContainer', 'docs_id': 17, 'description': 'Container with PML and other simulation objects', 'default_value': '_required_', 'is_optional': False}, {'name': 'config', 'type': 'SimulationConfig', 'docs_id': 18, 'description': 'Simulation configuration with gradient settings', 'default_value': '_required_', 'is_optional': False}, {'name': 'key', 'type': 'jax.Array', 'docs_id': 19, 'description': 'Random key for decompression', 'default_value': '_required_', 'is_optional': False}], 'examples': [{'type': 'Adding interface values', 'code': 'updated_arrays = fdtdx.fdtd.update.add_interfaces(time_step, arrays, objects, config, key)', 'description': 'This example shows how to use the add_interfaces function to add previously collected interface values back to the fields.'}], 'url': None, 'error': False}]